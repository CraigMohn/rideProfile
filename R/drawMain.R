#' plot heartrate, cadence, speed and more using color-driven
#'   data summaries to convey performance patterns
#'
#'
#' \code{rideProfile} creates a plot which uses the elevation profile
#'   and colored bands to compactly display the relationship between terrain,
#'   speed, cadence and heartrate on a given ride
#'
#' Generates a plot which compactly displays the elevation profile and its
#'    relationship with speed, cadence and heartrate.  Also displays clock
#'    information and shows location and approximate length of stops.
#'
#' @param track data frame or tibble containing track details including
#'    location and elevation data, as well as heartrate and cadence
#' @param summary data frame or tibble containing track summary from the
#'    data frames generated by \code{read_ride}
#' @param savefn name of output file, format is determined by the file
#'    extension specified, .pdf, .png or .jpg
#' @param title title printed over top center of diagram
#' @param palette palette to use in graphic (\code{"plasma"} or \code{"magma"}
#'    or \code{"inferno"} or \code{"viridis"})
#' @param naPlotColor name of color to use displaying NAs and zeros
#' @param verticalMultiplier default vertical exaggeration factor.  Default
#'    ranges from 25 to 60 depending on the length being plotted
#' @param ppm override calculated default number of points per mile
#' @param displayBands character vector of variables displayed under profile,
#'    in order from top to bottom
#' @param elevationShape shape to use for drawing the elevation plot
#' @param elevationColor variable to use to shade elevation line.  options are
#'    "speed","power","hr","cad", or color name
#' @param showStops draw marks for short and long stops on distance axis if
#'   time axis not drawn
#' @param showTime draw time axis - use FALSE to suppress,
#' @param showSummary display summary results if supplied
#'
#' @param stopToleranceMeters tolerance in meters for determining stop
#' @param minSecsRolling restarts shorter than this number of seconds
#'    considered to be part of stop
#' @param minNumPoints pad out the plot on the right if too short
#' @param imperial use mi and ft instead of km and m
#' @param ... arguments for other functions including color bounds
#'
#' @return a ggplot object
#'
#' @export
rideProfile <-  function(track,summary,savefn,title="Ride starting ",
                         palette="plasma",
                         naPlotColor="gray88",
                         verticalMultiplier=NA,ppm=NA,
                         displayBands=c("speed","grade","cad",
                                        "power","hr"),
                         elevationShape=NA,
                         elevationColor="speed",
                         showTime=TRUE,showSummary=TRUE,
                         showStops=TRUE,
                         stopToleranceMeters=20,
                         minSecsRolling=10,
                         minNumPoints=3000,
                         imperial=TRUE,
                         ...) {

  ##  set up some basic quantities - imperial versus metric
  if (imperial) {
    distance  <- milesFromMeters(track$distance.m)
    stopDistLim <- milesFromMeters(stopToleranceMeters)
  }
  else {
    distance <- kmFromMeters(track$distance.m)
    stopDistLim <- kmFromMeters(stopToleranceMeters)
  }
  dist <- distance[length(distance)]
  npoints <- numPointsXAxis(dist,ppm,imperial)
  distPerPoint <- dist/(npoints-1)
  ngraphpoints <- max(minNumPoints,npoints)
  walltime <- as.numeric(difftime(track$timestamp.s,track$timestamp.s[1],
                                  units="secs"))
  hours <- walltime[length(walltime)]/3600
  hoursPerPoint <- hours/(npoints-1)

  ##  set up list of color graph variables in order  - what will we add below the profile
  allBands <- c("speed","grade","cad","power","hr")
  hasdata <- c(TRUE,TRUE,
               any(!is.na(track$cadence.rpm)&track$cadence.rpm>0),
               any(!is.na(track$power.watts)&track$power.watts>0),
               any(!is.na(track$heart_rate.bpm)))
  names(hasdata) <- allBands
  displayBands <- tolower(displayBands)
  displayBands[displayBands=="cadence"] <- "cad"
  displayBands[displayBands=="heartrate"] <- "hr"
  displayBands <- unique(displayBands[displayBands %in% allBands])
  displayBands <- displayBands[hasdata[displayBands]]
  legendBands <- displayBands
  if ((elevationColor %in% allBands) &
      (hasdata[[elevationColor]]) &
      !(elevationColor %in% displayBands) )
    legendBands <- c(elevationColor,displayBands)
  orderBands <- match(allBands,displayBands)
  names(orderBands) <- allBands
  numBands <- sum(!is.na(orderBands))

  temp <- setupColorBounds(palette=palette,
                           legendwidth=dLegendWidth(npoints,distPerPoint,minNumPoints),
                           imperial=imperial,...)
  colorize <- temp[["colorize"]]
  colorLegends <- temp[["colorLegends"]]


  # grab the structure of starts and stops
  startsAndStops <- segSummary(time=walltime,dist=distance,
                               segment=track$segment,stopped=track$stopped,
                               subsegment=track$subsegment,
                               stopDistTolerance=stopDistLim,
                               stopRunLength=minSecsRolling)

  #  adjust elevation if track is a loop
  if (!is.na(summary$ride.loop) & summary$ride.loop) {
    if (abs(summary$deltaElev) > 1) {
      track$altitude.m <- track$altitude.m + seq(0,-summary$deltaElev,length.out=nrow(track))
    }
  }

  #  set up smoothed series
  smoothvar <- smoothSeries(track=track,imperial=imperial,...)

  grlist <- drawProfile(distancevec=distance,
                        smoothvecs=smoothvar,
                        colorize=colorize,
                        elevationColor=elevationColor,
                        distPerPoint=distPerPoint,
                        palettename=palette,
                        naPlotColor=naPlotColor,
                        vertMult=verticalMultiplier,
                        npoints=npoints,
                        minNumPoints=minNumPoints,
                        elevationShape=elevationShape,
                        imperial=imperial,
                        orderBands=orderBands,
                        showTime=showTime)

  if (showSummary & !missing(summary))
    grlist <- drawSummary(ggp=grlist,summary=summary,title=title)

  # put X axis below profile if not connecting with time scaled axis
  if (!showTime) {
    grlist <- drawXAxis(ggp=grlist,distance=distance,
                        startsAndStops=startsAndStops,
                        showStops=showStops,
                        distPerPoint=distPerPoint,
                        imperial=imperial,underLine=TRUE,
                        lineAtZero=TRUE)
  } else {
    grlist <- addGap(ggp=grlist,nrep=3)
  }

  ###  draw legends
  for (varband in legendBands) {
    grlist <- colorLegends[[varband]](ggp=grlist)
  }

  grlist <- addGap(ggp=grlist,nrep=1)

  for (varband in displayBands) {
    grlist <-
      data_band(ggp=grlist,xvar=distance,
                cvals=colorize[[varband]](smoothvar[[varband]]),
                segment=track$segment)
  }

  if (showTime) {
    #  draw opaque white background where faint gridlines aren't helpful
    grlist[["g"]] <- grlist[["g"]] +
      ggplot2::geom_rect(xmin=0,xmax=grlist[["xmax"]],
                         ymax=grlist[["ymin"]],
                         ymin=grlist[["ybottom"]],
                         color="white",fill="white")

    grlist <- drawXAxis(grlist,distance,startsAndStops=startsAndStops,
                        showStops=FALSE,distPerPoint,imperial=imperial,
                        underLine=FALSE,
                        lineAtZero=!all(is.na(orderBands)))
    grlist <- drawXTConnect(grlist,distance,walltime,
                            startsAndStops=startsAndStops,
                            distPerPoint,hoursPerPoint)
    grlist <- drawTAxis(grlist,walltime,
                        startsAndStops=startsAndStops,
                        distPerPoint,hoursPerPoint)

    for (varband in displayBands) {
      grlist <-
        data_band(ggp=grlist,xvar=walltime,
                  cvals=colorize[[varband]](smoothvar[[varband]]),
                  segment=track$segment)
    }
  }
#  this is key to having text being kept at an appropriate size.
  ymax <- grlist[["ymax"]]
  ymin <- grlist[["ymin"]]
  vertmult <- grlist[["vertmult"]]
  ngraphpoints <- grlist[["ngraphpoints"]]
  g <- grlist[["g"]]

  plot.width <- 0.5*(ngraphpoints/600)+0.75
  plot.height <- 0.5*(((ymax-ymin)*vertmult/(5280*distPerPoint))/600)*1.1 + 2.5

  if (!missing(savefn))
    ggsave(savefn,width=plot.width,height=plot.height,
           units="in",dpi=600,scale=1.3,limitsize=FALSE)
  return(g)

}
